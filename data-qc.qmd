---
title: "Rotorua QC"
execute:
  warning: false
format: 
  html:
    number-sections: true
    number-depth: 2
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
      number_sections: true
tbl-cap-location: top
---

```{r}
#| label: setup
#| eval: true
#| echo: false
#| include: false

unlink("data-raw", force = TRUE, recursive = TRUE)


```


```{r}
#| label: load-libraries
#| include: false

library(dplyr)
library(data.table)
library(tidyr)
library(readr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(readxl)
library(scattermore)
library(sf)
library(tmap)
library(DT)

# Set tmap mode and basemap
tmap_mode("view")
tmap_options(basemap.server = c("OpenStreetMap", "Esri.WorldImagery"))

# Set timezone to NZST
withr::local_locale(c("LC_TIME" = "C"))
withr::local_timezone("Etc/GMT-12")

# Load functions
source("R/qc_funs.R")

```

### Load data

The raw data was downloaded from the Bay of Plenty hydroTel SFTP server. The 
data were then collated into a CSV file which can be downloaded from 
[GitHub](https://github.com/limnotrack/f_rotorua/releases/tag/v0.0.1) or within
R using the `piggyback` package. The data are stored in the `data-raw` folder.

```{r}
#| label: load-data
#| message: false
#| warning: false
#| cache: true

download <- TRUE

if (download) {
  dir.create("data-raw", showWarnings = FALSE)
  # Hydrotel data
  piggyback::pb_download(
    file = "rotorua_data_raw.zip",
    dest = ".",
    repo = "limnotrack/f_rotorua",
    tag = "v0.0.1", overwrite = TRUE
  )
  
  # Unzip the file to tempdir
  tmp_dir <- tempdir()
  unzip("rotorua_data_raw.zip", exdir = tmp_dir)
  
  # Move files into data-raw
  file.copy(list.files(file.path(tmp_dir, "rotorua_data_raw"), full.names = TRUE),
            "data-raw", overwrite = TRUE)
  
  # Delete zip file
  unlink("rotorua_data_raw.zip", force = TRUE)
}

# Read in raw data
dat <- read_csv("data-raw/rotorua_sftp_compiled_raw.csv") |> 
  mutate(datetime = as_datetime(Date)) |> 
  select(-Date) |> 
  arrange(datetime)


```

### Load metadata

Load metadata about the site, site events, devices, and variables. This includes
the site location, device IDs, variable names, and sensor calibration data.

```{r}
#| label: load-metadata
#| include: true
#| echo: true
#| cache: true

site_sel <- "f_Rotorua"
site <- read_csv("data-raw/sites.csv", col_types = cols())
site_events <- read_csv("data-raw/site_events.csv", col_types = cols())
site_devices <- read_csv("data-raw/site_devices.csv", col_types = cols())

device_var <- read_csv("data-raw/device_variable.csv", col_types = cols())

device_position <- read_csv("data-raw/device_position.csv", col_types = cols())

sensor_reference <- read_csv("data-raw/sensor_reference.csv", col_types = cols())

sensor_calibrations <- read_csv("data-raw/sensor_calibrations.csv", col_types = cols())
sensor_scaling <- read_csv("data-raw/sensor_scaling.csv", col_types = cols())

variable_ref <- read_csv("data-raw/variables.csv", col_types = cols())

qc_filters <- read_csv("data-raw/qc_filters.csv", col_types = cols())

qc_update_df <- read_csv("data-raw/qc_update_table.csv", col_types = cols())

sensor_map <- map_sensors(site_devices = site_devices, 
                          device_var = device_var, 
                          device_position = device_position)
sensor_map

```

```{r}
#| label: fig-sensor-timeline
#| fig.cap: Sensor timeline.
#| echo: false

plot_sensor_timeline(sensor_map = sensor_map, variable_ref = variable_ref,
                     site_events = site_events, add_faults = TRUE)

```

```{r}
#| label: fig-site-events-timeline
#| fig.cap: Sensor timeline.
#| echo: false
#| fig.width: 8
#| fig.height: 10

# plot_site_events(site_events = site_events)

```

```{r}
#| label: delete-raw-data
#| include: false
#| echo: false

# Delete raw data
unlink("data-raw/rotorua_sftp_compiled_raw.csv", force = TRUE)
```


# Site location

Lake Rotorua is located in the Bay of Plenty region of New Zealand. The 
monitoring site is located near the centre of the lake around its deepest point.


```{r}
#| label: fig-site-location
#| fig.cap: Site location on Lake Rotorua.
#| echo: false

site_sf <- site |> 
  st_as_sf(coords = c("lon", "lat"), crs = 4326)

tm_shape(site_sf, name = "Site location") +
  tm_dots(size = 1, shape = 21, fill = "red") +
  tm_view(set_view = 12)

```


# Compile raw hydroTel data from BoP

Check no variables are time-aggregated

## Standardise to 15-minute data (i.e. modify any periods where data were logged every 5-minutes.

-   Circular average for wind direction, sum for rainfall, mean for everything else.

```{r}
#| label: standardise-15min
#| cache: true

rain <- dat |> 
  select(datetime, contains("rainfall")) |>
  standardise(15, FUN = sum, na.rm = TRUE)

wind_dir <- dat |> 
  select(datetime, contains("wind_direction")) |>
  standardise(15, FUN = avg_circ)

mean_vars <- c("datetime", 
               "do_cont_0.5m", "do_cont_20m", "do_sat_0.5m", 
               "do_sat_20m", "do_temp_0.5m", "do_temp_20m", 
               # "light_level_1", "light_level_2",
               "ph_decommissioned", "ph_raw",
               "temp_0.5m", "temp_2.5m", "temp_4.5m", 
               "temp_6.5m", "temp_8.5m",  "temp_10.5m", "temp_12.5m",
               "temp_14.5m", "temp_16.5m", "temp_18.5m",  "temp_20.5m", 
               # "temphion_3", 
               "phyco", 
               # "trios_chl_a",
               "chlorophyll", 
               "air_temp", "humidity", "barometric_pressure",
               "wind_speed_m-s", "wind_speed")
means <- dat |>
  select(contains(mean_vars)) |>
  standardise(15, FUN = mean, na.rm = TRUE)

date_df <- data.frame(datetime = seq.POSIXt(round_date(min(dat$datetime), "15 mins"),
                                            round_date(max(dat$datetime), "15 mins"),
                                            by = 15*60))

dat2 <- list(date_df, means, rain, wind_dir) |> 
  # left_join(means, by = "datetime") |>
  purrr::reduce(function(x, y) {left_join(x, y, by = "datetime")}) |>
  arrange(datetime)

```

```{r}
#| label: check-15min
#| include: false
#| echo: false

# Check that datetime is on a 15 minute interval
chk <- dat2 |> 
  mutate(time_diff = c(0, diff(as.numeric(datetime)))) |> 
  filter(time_diff != 900)

ggplot() +
  geom_scattermore(data = chk, aes(x = datetime, y = time_diff)) +
  theme_bw()


```


## Check and correct any variable name misalignments

(e.g., temperature depths incorrectly assigned , Temperature & DO swapped (e.g., Rotorua around 2016)

### DO at 0.5m

```{r}
#| label: fig-plotly-data-do-misalignment
#| fig.cap: DO and temperature data misalignment at 0.5m.
#| eval: false

plotly_data(dat2, y1 = "do_cont_20m", y2 = "do_temp_20m", sub = 50)
```


Swap DO & temperature back into their correct columns.

```{r}
#| label: reassign-variables-do-cont-20m-1
#| warning: false
#| message: false
#| fig.cap: Reassigned DO data to correct periods second period.

swap_start <- "2021-03-23 19:00:00"
swap_end <- "2022-02-02 15:00:00"

dat2 <- swap_cols(dat2, var1 = "do_cont_20m", var2 = "do_temp_20m", 
                  date_range = c(swap_start, swap_end))

```

```{r}
#| label: fig-reassign-variables-do-cont-20m-1
#| warning: false
#| message: false
#| fig.cap: Reassigned DO data to correct periods second period.
#| eval: false

plotly_data(dat2, y1 = "do_cont_20m", y2 = "do_temp_20m",
            date_range = c(swap_start, swap_end), buffer = 240, sub = 20)

```


```{r}
#| label: fig-chla
#| warning: false
#| message: false
#| fig.cap: Reassigned DO data to correct periods second period.
#| eval: false

ggplot() +
  geom_scattermore(data = dat2, aes(x = datetime, y = chlorophyll, colour = "chl1")) +
  geom_scattermore(data = dat2, aes(x = datetime, y = trios_chl_a, colour = "chl2")) +
  coord_cartesian(ylim = c(0, 500)) +
  theme_bw()

```


Sensors were all 0.5-1m, we will call them 1m.

Map column names to standard names used in the database. 

```{r}
#| label: column-mapping-standard-names

col_mapping <- c(
  # "battery_voltage", 
  "f_chl_d100" = "chlorophyll",
  # "f_chl_d110" = "trios_chl_a",
  "f_phyc_d100" = "phyco",
  "c_do_d100" = "do_cont_0.5m",
  "c_do_d2000" = "do_cont_20m",
  "c_do_sat_d100" = "do_sat_0.5m",
  "c_do_sat_d2000" = "do_sat_20m",
  "t_wtr_d50" = "temp_0.5m",
  "t_wtr_d100" = "do_temp_0.5m",
  "t_wtr_d250" = "temp_2.5m",
  "t_wtr_d450" = "temp_4.5m",
  "t_wtr_d650" = "temp_6.5m",
  "t_wtr_d850" = "temp_8.5m",
  "t_wtr_d1050" = "temp_10.5m",
  "t_wtr_d1250" = "temp_12.5m",
  "t_wtr_d1450" = "temp_14.5m",
  "t_wtr_d1650" = "temp_16.5m",
  "t_wtr_d1850" = "temp_18.5m",
  "t_wtr_d2000" = "do_temp_20m",
  "t_wtr_d2050" = "temp_20.5m",
  "c_ph_d100" = "ph_decommissioned",
  "c_ph_raw_d100" = "ph_raw",
  
  "t_air_h150" = "air_temp",
  "pr_baro_h150" = "barometric_pressure", 
  "pp_rain_h150" = "rainfall",
  "h_rh_h150" = "humidity",
  "r_swd_h150" = "solar_radiation",
  "w_spd_h150" = "wind_speed_m-s",
  "w_dir_h150" = "wind_direction")


dat3 <- standardise_columns(dat2, col_mapping)


```

Write level one raw data to file.

```{r}
#| label: write-level1-raw-data
#| eval: false

write_csv(dat3, "data-raw/rotorua_sftp_compiled_raw_level1.csv")
```

```{r}
#| label: shiny-explore-raw-data
#| eval: false
#| include: false
#| echo: false

viz_data(data = dat, long = FALSE, site_events = site_events)

```



# Sensor Attribution

Map each sensor onto each data point.

```{r}
#| label: load-raw-level0p5
#| include: false
#| echo: false
#| eval: false

raw <- read_csv("data-raw/rotorua_sftp_compiled_raw_level1.csv",
                col_types = cols())

```

```{r}
#| label: assign-raw-data
#| include: false
#| echo: false

raw <- dat3

```

```{r}
#| label: check-sensor-mapping
#| include: false
#| echo: false

sensor_map[!sensor_map$var_ref_id %in% names(raw), ]

names(raw)[!names(raw) %in% sensor_map$var_ref_id]
```


Convert wide dataframe to standardised long format.

```{r}
#| label: pivot-wide-to-long-devices

raw_long <- raw |> 
  pivot_longer(cols = -datetime, names_to = "var_ref_id", values_to = "raw_value") 

# Conditional join raw_long with sensor_map using var_ref_id and when datetime is between date_from and date_to
raw_long_device <- sensor_map |> 
  # slice(1:3) |>
  group_by(device_id) |> 
  left_join(raw_long, by = "var_ref_id") |>
  filter(datetime >= date_from & datetime <= date_to) |> 
  ungroup() |> 
  arrange(device_id, datetime) |>
  mutate(qc_value = round(raw_value, 2),
         qc_flag = "", 
         qc_code = case_when(
           is.na(raw_value) ~ "QC 100",
           TRUE ~ "QC 200"
         )) |> 
  select(site, datetime, device_id, var_abbr, var_ref_id, raw_value, qc_value, 
         qc_flag, qc_code) |> 
  distinct(datetime, var_ref_id, .keep_all = TRUE) 

head(raw_long_device)

```


```{r}
#| label: shiny-explore-long-data
#| eval: false
#| include: false
#| echo: false

viz_data(data = raw_long_device, site_events = site_events)

```

### Sensor plots

::: {.panel-tabset}
```{r}
#| label: sensor-plots
#| results: asis
#| fig-width: 14
#| fig-height: 6


sel_vars <- raw_long_device |> 
  select(var_ref_id) |>
  distinct() |> 
  arrange(var_ref_id) |>
  pull()
v <- sel_vars[9]

for (v in sel_vars) {
  
  var_name <- decode_var_ref(var_ref = v, variable_ref = variable_ref)
  
  cat('## ', paste(var_name$var_abbr, var_name$value_m, "m"), '\n\n')
  
  p <- plot_sensor(data = raw_long_device, var_ref_id = v,
                   variable_ref =  variable_ref, 
                   sensor_calibrations = sensor_calibrations, 
                   sensor_reference = sensor_reference,
                   sensor_scaling = sensor_scaling) +
    theme_bw(base_size = 16) +
    theme(legend.position = "bottom")
  print(p)
  
  cat('\n\n')
  
}

```
:::

## Remove based on site events

```{r}
#| label: buoy-out-of-water
#| fig.cap: Check when the buoy was out of the water.
#| fig.width: 8
#| fig.height: 10

raw_long_device <- raw_long_device |> 
  remove_site_events(site_events = site_events, sensor_map = sensor_map) 

raw_long_device |> 
  filter(qc_flag == "sensor_fault") 

# plot_qc_data(data = raw_long_device_filt)

```


# Meteorology

## Relative humidity drift

Over the entire period, the relative humidity sensor appears to have drifted
in the middle of the time period.

```{r}
#| label: rh-drift
#| warning: false
#| message: false

raw_long_device |> 
  filter(var_ref_id == "h_rh_h150") |> 
  summary()

```

```{r}
#| label: fig-rh-drift
#| warning: false
#| message: false
#| fig.cap: Relative humidity drift.

plot_sensor(data = raw_long_device, var_ref_id = "h_rh_h150",
            variable_ref =  variable_ref, 
            sensor_calibrations = sensor_calibrations,
            sensor_reference = sensor_reference,
            sensor_scaling = sensor_scaling) +
  geom_hline(yintercept = 100, linetype = "dashed", colour = "red") +
  coord_cartesian(ylim = c(0, 100)) 


```

# Quality control

We used a set of quality control codes to assess the quality of the data. The
codes are from the [National Environmental Monitoring Standards (NEMS)](https://www.nems.org.nz/). The codes are 
as follows:

```{r}
#| label: qc-codes

qc_codes <- c("Missing Record" = "QC 100",
              "No Quality or Non Verified" = "QC 200",
              "Synthetic" = "QC 300",
              "Poor Quality" = "QC 400",
              "Fair Quality" = "QC 500",
              "Good Quality" = "QC 600")

qc_code_col_scale = c(
  "QC 100" = "#FF0000",
  "QC 200" = "#8B5A00",
  "QC 300" = "#D3D3D3",
  "QC 400" = "#FFA500",
  "QC 500" = "#00BFFF",
  "QC 600" = "#006400"
)

qc_df <- data.frame(
  qc_code = qc_codes,
  qc_zone = names(qc_codes),
  qc_code_col = unname(qc_code_col_scale),
  stringsAsFactors = FALSE
)

qc_df |> 
  datatable(rownames = FALSE,
            options = list(
              pageLength = 6,
              dom = "t",
              columnDefs = list(list(className = 'dt-center', targets = "_all"))
            )
  ) |> 
  formatStyle(
    'qc_code_col',
    target = 'row',
    backgroundColor = styleEqual(qc_code_col_scale, qc_code_col_scale)
  )

```



# pH standardisation

To standardise the pH data, we apply a sensor scaling based on reference pH 
measurements of 4, 7, and 10. The pH sensor is a ISFET sensor, which is a type 
of pH sensor that uses a field-effect transistor (FET) to measure the pH of a
solution.

We use the raw pH signal which is a value between 0 and 1000. The pH sensor
is then mapped onto the reference points and corrected for drift.

```{r}
#| label: fig-ph-standardisation
#| fig.cap: Reference pH values compared to raw sensor output. 
#| include: false
#| echo: false


# viz_data(data = raw_long_device, variable = "var_ref_id",
#          value = "qc_value")
var_ref_id <- "c_ph_raw_d100"
ph_count <- raw_long_device |> 
  filter(var_abbr %in% c("c_ph")) |>
  # apply_adjustment(var_ref_id = "c_phraw_d100", FUN = \(x) x / 10) |> 
  scale_data(var_ref_id = "c_ph_d100", sensor_scaling) |> 
  mutate(
    # var_abbr = "c_ph_raw",
    # var_ref_id = "c_ph_raw_d100",
    # qc_value = case_when(
    #   datetime > as_datetime("2019-04-01") & 
    #     var_ref_id == "c_phraw_d100" ~ NA,
    #   datetime > as_datetime("2016-03-02") & 
    #     var_ref_id == "c_ph_d100" ~ NA, 
    #   .default = qc_value
    # )
  ) 

ph_raw_count <- raw_long_device |> 
  filter(var_abbr %in% c("c_ph_raw")) 

ph_count |> 
  filter(!is.na(qc_value)) |>
  group_by(var_ref_id) |>
  summarise(min = min(qc_value, na.rm = TRUE), 
            mean_v = mean(raw_value, na.rm = TRUE),
            mean = mean(qc_value, na.rm = TRUE),
            max = max(qc_value, na.rm = TRUE),
            n = n()
  )

# plotly_data(data = ph_count, y1 = "c_ph_d100", y2 = "c_phraw_d100", sub = 20)


sensor_refs <- sensor_reference |> 
  dplyr::filter(device_id %in% ph_count$device_id,
                # date > "2013-06-28",
                value_actual %in% c(4, 7, 10), 
                value_measured > 0,
                units_sensor == "counts") 




ggplot() +
  geom_point(data = ph_raw_count, aes(datetime, qc_value, colour = var_ref_id), size = 0.2) +
  geom_point(data = ph_count, aes(datetime, qc_value, colour = var_ref_id), size = 0.2) +
  geom_point(data = sensor_refs, aes(date, value_measured,
                                     colour = factor(value_actual)), size = 2) +
  geom_smooth(data = sensor_refs, aes(date, value_measured,
                                      colour = factor(value_actual)),
              method = "lm") +
  coord_cartesian(ylim = c(350, 1000)) +
  theme_bw()

```

Drift corrected pH values

```{r}
#| label: fig-ph-drift-corrected
#| fig.cap: Drift corrected pH values.
#| fig.width: 8
#| fig.height: 6


ph_raw <- raw_long_device |> 
  filter(var_abbr %in% c("c_ph_raw")) |> 
  mutate(new_val = qc_value) |> 
  select(datetime, new_val)

ph_dc <- ph_count |> 
  filter(var_abbr %in% c("c_ph")) |> 
  left_join(ph_raw, by = "datetime") |>
  mutate(
    qc_value = case_when(
      is.na(qc_value) ~ new_val, .default = qc_value
    )
  )

date_range <- raw_long_device |> 
  filter(var_abbr %in% c("c_ph", "c_ph_raw")) |>
  pull(datetime) |>
  range()

# ph_dc <- ph #ph_count |>
# filter(!is.na(qc_value) & !duplicated(datetime)) |>
# mutate(var_ref_id = "c_ph_d100", var_abbr = "c_ph") 

any(duplicated(ph_dc$datetime))

data <- ph_dc
ph_dc <- ph_dc |> 
  adjust_linear_drift(var_ref_id = "c_ph_d100", sensor_refs = sensor_refs, 
                      date_range = date_range, expand_coeffs = TRUE) |> 
  apply_adjustment(var_ref_id = "c_ph_d100",
                   # date_range = c("2013-07-19", "2017-07-13"),
                   FUN = \(x) ifelse(x <= 5 | x >= 10, NA, x)) |> 
  mutate(
    qc_code = case_when(
      is.na(raw_value) ~ "QC 100",
      is.na(qc_value) ~ "QC 200",
      .default = qc_code
    )
  )
summary(ph_dc)

# viz_data(data = ph_dc, var_abbr = "var_ref_id",
#          site_events = site_events)

# plotly_data(ph_dc, y1 = "c_ph_d100", sub = 20)


ph_orig <- raw_long_device |> 
  filter(var_abbr %in% c( "c_ph")) |>
  mutate(
    raw_value = case_when(
      # datetime > as_datetime("2019-04-01") & 
      #   var_ref_id == "c_phraw_d100" ~ NA,
      datetime > as_datetime("2017-07-13") & 
        var_ref_id == "c_ph_d100" ~ NA, 
      .default = raw_value
    )
  ) |> 
  filter(!is.na(raw_value)) 


# plotly_data(data = ph_dc, y1 = "drift_correct", sub = 20)

ggplot() +
  geom_point(data = ph_orig, aes(datetime, raw_value, colour = "Original"),
             size = 0.2) +
  geom_point(data = ph_dc, aes(datetime, qc_value, 
                               colour = "Drift corrected"), size = 0.2) +
  coord_cartesian(ylim = c(5, 11)) +
  theme_bw()


```

```{r}
#| label: replace-ph-values
#| fig.cap: Replace pH values with drift corrected values.
#| include: false
#| echo: false

raw_long_device2 <- raw_long_device |> 
  # Replace pH values with drift corrected values
  filter(!var_abbr %in% c("c_ph")) |>
  bind_rows(ph_dc)

# viz_data(data = raw_long_device2, variable = "var_ref_id",
#            site_events = site_events)

# left_join(ph_dc |> 
#             select(datetime, var_ref_id, drift_correct) |> 
#             rename(raw_value = drift_correct), 
#           by = c("datetime", "var_ref_id")) |> 
# mutate(raw_value = coalesce(raw_value.x, raw_value.y)) |> 
# select(-c(raw_value.x, raw_value.y))

# plotly_data(raw_long_device2, y1 = "c_ph_d100", sub = 20)


```

## Basic QC - filters

a.	Filter extreme outliers (order of magnitude plus)
b.	Filter repetitions/stuck values (careful genuine repeats e.g., rainfall == 0)
c.	Remove data for any periods where buoy was clearly out of the water (see notes or visual check of data)


```{r}
#| label: basic-qc-filter-extreme

raw_long_device_filt <- apply_filters(raw_long_device2, filters = qc_filters)

```


```{r}
#| label: fig-plot-raw-long-device-filt
#| fig.cap: Plot raw data with basic QC filters applied.

plot_flag_ts(raw_long_device_filt)
```
```{r}
#| label: check-for-duplicates
#| include: false
#| echo: false
#| eval: false

# dups <- raw_long_device_filt |> 
#   group_by(var_ref_id, datetime) |> 
#   summarise(n = n()) |> 
#   filter(n > 1)
# dups 
```


# Fluorescence sensors

```{r}
#| label: fig-fluorescence-sensors
#| fig.cap: Fluorescence sensors an their associated device ids.

fluor_df <- raw_long_device_filt |> 
  filter(var_abbr %in% c("f_chl", "f_phyc")) |> 
  apply_adjustment("f_chl_d100",
                   FUN = \(x) ifelse(x <= 0, NA, x)) |> 
  apply_adjustment("f_chl_d100",
                   FUN = \(x) ifelse(x >= 1000, NA, x))

# viz_data(data = fluor_df, var_abbr = "var_ref_id",
#          site_events = site_events,
#          raw_value = "qc_value")


fluor_sensors <- sensor_map |> 
  filter(device_id %in% fluor_df$device_id) |> 
  select(device_id, var_ref_id, date_from, date_to)

sensor_refs <- sensor_reference |> 
  left_join(fluor_sensors, by = "device_id") |>
  filter(device_id %in% fluor_sensors$device_id,
         !is.na(value_actual)
         # date > "2013-06-28",
         # value_actual %in% c(4, 7, 10), 
         # units_sensor == "counts"
  ) 

sensor_scales <- sensor_scaling |> 
  arrange(date) |>
  filter(device_id %in% fluor_sensors$device_id) 

plot_sensor(data = fluor_df, var_ref_id = c("f_chl_d100"),#, "f_phyc_d100"),
            variable_ref =  variable_ref, 
            sensor_calibrations = sensor_calibrations, 
            sensor_reference = sensor_reference,
            sensor_scaling = sensor_scaling, clip_ylim = F) 

```

Correct fluorescence data by removing bad data and applying corrections to get 
the chlorophyll at it its raw 0-5V raw signal, then recorrecting to get the
corrected chlorophyll value inrelative fluorescene units (RFU).

```{r}
#| label: fig-fluorescence-sensors-chla-corr-1
#| fig.cap: Corrected chlorophyll data. Points are coloured according to the quality control codes.

raw_chl <- fluor_df |> 
  filter(var_ref_id == "f_chl_d100")

# viz_data(data = raw_chl, site_events = site_events, variable = "var_ref_id", 
#          value = "qc_value")

sensor_scales <- sensor_scaling |> 
  filter(device_id %in% raw_chl$device_id) |> 
  select(device_id, date, offset, multiplier, range) 

raw_v <- raw_chl |> 
  mutate(var_ref_id = "f_chl_raw_v_d100",
         var_abbr = "f_chl_raw_v",
         # raw_value = NA_real_
  ) |>
  left_join(sensor_scales, by = c("device_id", "datetime" = "date")) |>
  tidyr::fill(offset, multiplier, .direction = "down") |>
  mutate(qc_value = (qc_value - offset) / multiplier,
         qc_code = case_when(
           is.na(raw_value) ~ "QC 100",
           is.na(qc_value) ~ "QC 200",
           .default = "QC 500"
         )
  ) |>
  # apply_adjustment("f_chl_raw_v_d100",
  #                  date_range = c("2009-12-02 10:53:01", "2010-01-15 11:51:31"),
  #                  FUN = \(x) x / 10
  # ) |>
  apply_adjustment("f_chl_raw_v_d100",
                   date_range = c("2013-04-10 11:59:16", "2014-08-28 04:09:46"),
                   FUN = \(x) x / 5
  ) |>
  apply_adjustment("f_chl_raw_v_d100",
                   date_range = c("2015-01-30 14:02:14", "2016-01-23 10:57:48"),
                   FUN = \(x) x / 10
  ) |>
  apply_adjustment("f_chl_raw_v_d100",
                   date_range = c("2019-01-29 09:34:58", "2019-08-01 15:16:35"),
                   FUN = \(x) x / 10
  ) |>
  apply_adjustment("f_chl_raw_v_d100",
                   date_range = c("2019-08-01 15:11:20", "2022-01-18 08:54:32"),
                   FUN = \(x) x * 3
  ) #|>
# # brief period where it was 20-fold higher, NYE issue across HydroTel??
# apply_adjustment("f_chl_raw_v_d100",
#                  date_range = c("2007-12-31 23:59:00", "2008-01-04 10:25"),
#                  FUN = \(x) x / 20
# ) |>
# # looks like changed to lower range on this date\
# # still seapoint sensor, values approx x3 so guess was changed from 0-50 to 0-15
# apply_adjustment("f_chl_raw_v_d100",
#                  date_range = c("2013-04-10 16:14", "2015-12-24 08:24"),
#                  FUN = \(x) x * 15 / 50
# ) |>
# # values higher... /10?
# apply_adjustment("f_chl_raw_v_d100",
#                  date_range = c("2015-12-24 08:24", "2016-01-20 11:53"),
#                  FUN = \(x) x / 10
# ) |>
# # later period where it was also 10-fold higher for some reason?
# apply_adjustment("f_chl_raw_v_d100",
#                  date_range = c("2019-01-29 09:00", "2019-08-01 15:13"),
#                  FUN = \(x) x / 10
# ) |>
# # seapoint sensor was always logged at 10x proper range, but applying an
# # approx correction to match to Turner sensor values..
# apply_adjustment("f_chl_raw_v_d100",
#                  date_range = c("2007-07-13 14:45", "2016-02-05 05:14"),
#                  FUN = \(x) x / 10 * 3
# ) |>
#     # first few years of Turner was logged with multiplier = 20, when should have been 10
# apply_adjustment("f_chl_raw_v_d100",
#                  date_range = c("2016-02-05 05:14", "2019-06-04 14:41"),
#                  FUN = \(x) x / 2
# ) #|>
# update_qc_code_vectorized(qc_update_df = qc_update_df)

# chl_adj <- viz_data(data = raw_v, site_events = site_events, variable = "var_ref_id",
#          value = "qc_value")
# 
# write_csv(chl_adj, "qc_adj_f_chl_d100_raw_V.csv")

# plot_raw_qc(data = raw_v, variable_ref = variable_ref)

# chl_adj <- read_csv("qc_adj_f_chl_d100_raw_V.csv", col_types = cols()) 
# qc_update_df <- bind_rows(qc_update_df, chl_adj)
# write_csv(qc_update_df, "qc_update_df.csv")

chla_corr <- raw_v |>
  update_qc_code_vectorized(qc_update_df = qc_update_df) |>
  mutate(qc_value = qc_value * 10,
         var_ref_id = "f_chl_d100",
         var_abbr = "f_chl",
  )


chla_corr |> 
  plot_sensor(var_ref_id = "f_chl_d100", variable_ref =  variable_ref, 
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE,
              colour = "qc_code")
```


## Load in field measurements

Compare field measurements to sensor data. 

```{r}
#| label: fig-compare-field-measurements
#| fig.cap: Compare field measurements to sensor data.
#| fig.width: 8
#| fig.height: 6

field <- read_csv("data-raw/rotorua_field_data.csv") |> 
  mutate(Date2 = as.Date(Date))

chla <- field |> 
  filter(grepl("Chla", Parameter)) |> 
  select(Date2, LocationName, DepthFrom, Sample_Depth, Value) |> 
  rename(Date = Date2)

ref_times <- raw_long_device_filt |> 
  mutate(hour = hour(datetime)) |> 
  filter(var_abbr %in% c("f_chl")) |>
  filter(hour %in% c(0:6, 21:23)) |> 
  filter(as.Date(datetime) %in% as.Date(chla$Date))

sub_sensor <- raw_v |> 
  mutate(Date = as.Date(datetime)) |>
  filter(datetime %in% ref_times$datetime) |> 
  group_by(Date, device_id) |>
  summarise(qc_value = mean(qc_value, na.rm = TRUE),
            median = median(qc_value, na.rm = TRUE), .groups = "drop")



df <- sub_sensor |> 
  left_join(chla, by = c("Date" = "Date")) |> 
  mutate(year = year(Date)) |> 
  filter(!is.na(qc_value))

ggplot() +
  geom_point(data = df, aes(qc_value, Value, colour = LocationName)) +
  geom_smooth(data = df, aes(qc_value, Value, colour = LocationName), method = "lm") +
  # facet_wrap(year~device_id, scales = "free") +
  labs(x = "Sensor value (Volts)",
       y = "Field value (ug/L)") +
  coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(legend.position = "bottom") 

ggplot() +
  geom_point(data = df, aes(qc_value, Value, colour = device_id)) +
  geom_smooth(data = df, aes(qc_value, Value, colour = device_id), method = "lm") +
  facet_wrap(~device_id, scales = "free") +
  labs(x = "Sensor value (Volts)",
       y = "Field value (ug/L)") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(legend.position = "bottom") 



```


```{r}
#| label: fig-compare-field-measurements-2
#| fig.cap: Compare field measurements to sensor data.
#| echo: false
#| include: false

ggplot() +
  geom_point(data = df, aes(Date, Value, colour = LocationName)) +
  geom_point(data = df, aes(Date, qc_value*10)) +
  facet_wrap(year~device_id, scales = "free") +
  labs(x = "Sensor value (Volts)",
       y = "Field value (ug/L)") +
  coord_cartesian(ylim = c(0, 50)) +
  theme_bw()


```

## Phycocyanin data

Repeat similar procedure to phycocyanin data.

```{r}
#| label: subset-phyco

phyc_corr <- fluor_df |> 
  filter(var_ref_id == "f_phyc_d100",
         duplicated(datetime))

# viz_data(data = phyc_corr, qc_update_df = qc_update_df, 
#          site_events = site_events, variable = "var_ref_id",
#          value = "qc_value")

sensor_scales <- sensor_scaling |> 
  filter(device_id %in% phyc_corr$device_id) |> 
  arrange(date) |> 
  select(device_id, date, offset, multiplier, range) 

phyc_corr <- phyc_corr |>
  left_join(sensor_scales, by = c("device_id", "datetime" = "date")) |> 
  tidyr::fill(offset, multiplier, .direction = "down") |>
  mutate(qc_value = (qc_value - offset) / multiplier,
         var_ref_id = "f_phyc_raw_v_d100",
         var_abbr = "f_phyc_raw_v"
  ) |> 
  drift_correction(var_ref_id = "f_phyc_raw_v_d100", 
                   date_range = c("2013-02-21 12:04:53", "2013-06-26 23:55:06"), 
                   low = c(0, 0, 0), high = c(0.2, 0.2, 0.39)) 
```


```{r}
#| label: shiny-update-qc-code-phyco
#| include: false
#| echo: false
#| eval: false

qc_update_df <- viz_data(data = phyc_corr, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "qc_update_df.csv")
```


```{r}
#| label: plot-raw-phyco
#| include: false
#| echo: false
#| eval: false

# qc_update_df <- qc_update_df |> 
#   mutate(
#     var_ref_id = if_else(var_ref_id == "f_phyc_d100", "f_phyc_raw_v_d100", var_ref_id)
#   )

phyc_corr <- phyc_corr |> 
  update_qc_code_vectorized(qc_update_df = qc_update_df)

plot_raw_qc(data = phyc_corr, variable_ref = variable_ref, ylim = c(0, 5))
```


```{r}
#| label: fig-phycocyanin-qc
#| fig.cap: Phycocyanin data quality control.

phyc_corr <- phyc_corr |> 
  mutate(qc_value = qc_value, # * 10,
         var_ref_id = "f_phyc_d100",
         var_abbr = "f_phyc"
  )

phyc_corr |> 
  plot_sensor(var_ref_id = "f_phyc_d100", variable_ref =  variable_ref, 
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling,
              clip_ylim = FALSE, colour = "qc_code")
```


```{r}
#| label: fig-compare-sensor-references
#| include: false
#| echo: false
#| eval: false

sensor_refs <- sensor_reference |> 
  filter(device_id %in% phyc_corr$device_id)

ggplot() +
  # geom_point(data = fluor_df, aes(datetime, raw_value), size = 0.2) +
  geom_point(data = sensor_refs, aes(value_actual, value_measured)) +
  geom_smooth(data = sensor_refs, aes(value_actual, value_measured),
              method = "lm") +
  # geom_abline(intercept = 0, slope = 1) +
  # facet_wrap(~var_ref_id, scales = "free", ncol = 1) +
  theme_bw()


ggplot() +
  geom_point(data = sensor_refs, aes(date, value_measured,
                                     colour = factor(value_actual)), size = 2) +
  geom_smooth(data = sensor_refs, aes(date, value_measured,
                                      colour = factor(value_actual)),
              method = "lm") +
  theme_bw()
```


# Oxygen sensors

Remove bad data and correct for linear drift

```{r}
do_1m <- raw_long_device_filt |> 
  filter(var_ref_id %in% c("c_do_sat_d100"))

plot_raw_qc(data = do_1m, variable_ref = variable_ref, ylim = c(80, 150))
```

```{r}
#| label: shiny-update-qc-code-do-sat-d100
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = do_1m, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "qc_update_df.csv")

do_1m <- do_1m |> 
  drift_correction(var_ref_id = "c_do_sat_d100", 
                   date_range = c("2008-11-18 19:09:48", "2009-05-11 11:32:59"), 
                   low = c(0, 0, 0), high = c(98, 100, 110)) |>
  
  update_qc_code_vectorized(qc_update_df = qc_update_df)
```

```{r}

# do_1m |> 
#   viz_data(qc_update_df = qc_update_df, site_events = site_events,
#            variable = "var_ref_id", value = "qc_value")

```

```{r}
#| label: shiny-update-qc-code-do-sat-d100-v2
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = do_1m, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "qc_update_df.csv")

do_1m <- do_1m |> 
  update_qc_code_vectorized(qc_update_df = qc_update_df)
```


```{r}
#| label: fig-oxygen-1m-qc
#| fig.cap: Oxygen sensor data quality control.

do_1m |> 
  # plotly_data(y1 = "c_do_sat_d100", sub = 20)
  plot_sensor(var_ref_id = c("c_do_sat_d100"), variable_ref =  variable_ref, 
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE,
              colour = "qc_code") 

```

```{r}
#| label: subset-oxygen-20m-qc
do_20m <- raw_long_device_filt |> 
  filter(var_ref_id %in% c("c_do_sat_d2000")) |> 
  update_qc_code_vectorized(qc_update_df = qc_update_df)
```


```{r}
#| label: shiny-update-qc-code-do-sat-d2000
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = do_20m, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "data-raw/qc_update_df.csv")
```

```{r}
#| label: fig-oxygen-20m-qc
#| fig.cap: Oxygen sensor data at 20m quality control.


do_20m <- do_20m 


do_20m |> 
  # plotly_data(y1 = "c_do_sat_d1000", sub = 20)
  plot_sensor(var_ref_id = c("c_do_sat_d2000"), variable_ref =  variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = F, colour = "qc_code") +
  geom_hline(yintercept = 0)


```

# Recalculate DO concentrations using temperature and DO saturation

```{r}
#| label: do-concentration-1m-calc

temp_1m <- raw_long_device_filt |> 
  filter(var_ref_id == "t_wtr_d100") |> 
  select(datetime, raw_value) |> 
  rename(temp = raw_value)

pr_baro <- raw_long_device_filt |> 
  filter(var_ref_id == "pr_baro_h150") |> 
  select(datetime, raw_value) |> 
  rename(pr_baro = raw_value)

do_conc2_1m <- left_join(do_1m, temp_1m, by = "datetime") |> 
  left_join(pr_baro, by = "datetime") |> 
  mutate(do_sat_mgL = calc_DOsat_mg(temp, pr_baro),
         var_abbr = "c_do",
         var_ref_id = "c_do2_d100",
         qc_value = qc_value / 100 * do_sat_mgL
  ) |> 
  select(datetime, var_ref_id, site, device_id, var_abbr, qc_value, qc_flag)

do_conc_1m <- raw_long_device_filt |> 
  filter(var_ref_id == "c_do_d100") |> 
  select(datetime, var_ref_id, site, device_id, var_abbr, raw_value)


do_conc2_1m <- do_conc2_1m |> 
  mutate(var_ref_id = "c_do_d100") |> 
  select(datetime, var_ref_id, site, device_id, var_abbr, qc_value,
         qc_flag)

do_conc3_1m <- left_join(do_conc_1m, do_conc2_1m, by = c("datetime", "var_ref_id", "site", "device_id", "var_abbr")) |> 
  mutate(
    qc_code = case_when(
      !is.na(qc_value) ~ "QC 300",
      is.na(raw_value) ~ "QC 100",
      is.na(qc_value) ~ "QC 200"
    )
  )

```

```{r}
#| label: shiny-update-qc-code-do-d100-2
#| include: false
#| echo: false
#| eval: false

qc_update_df <- viz_data(data = do_conc3_1m, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)

```


```{r}
#| label: do-concentration-20m-calc

do_conc3_1m <- do_conc3_1m |> 
  update_qc_code_vectorized(qc_update_df = qc_update_df)


temp_20m <- raw_long_device_filt |> 
  filter(var_ref_id == "t_wtr_d2000") |> 
  select(datetime, raw_value) |> 
  rename(temp = raw_value)

pr_baro <- raw_long_device_filt |> 
  filter(var_ref_id == "pr_baro_h150") |> 
  select(datetime, raw_value) |> 
  rename(pr_baro = raw_value)

do_conc2_20m <- left_join(do_20m, temp_20m, by = "datetime") |> 
  left_join(pr_baro, by = "datetime") |> 
  mutate(do_sat_mgL = calc_DOsat_mg(temp, pr_baro),
         var_abbr = "c_do",
         var_ref_id = "c_do2_d100",
         qc_value = qc_value / 100 * do_sat_mgL
  ) |> 
  select(datetime, var_ref_id, site, device_id, var_abbr, qc_value, qc_flag)

do_conc_20m <- raw_long_device_filt |> 
  filter(var_ref_id == "c_do_d2000") |> 
  select(datetime, var_ref_id, site, device_id, var_abbr, raw_value)


do_conc2_20m <- do_conc2_20m |> 
  mutate(var_ref_id = "c_do_d2000") |> 
  select(datetime, var_ref_id, site, device_id, var_abbr, qc_value,
         qc_flag)

do_conc3_20m <- left_join(do_conc_20m, do_conc2_20m, by = c("datetime", "var_ref_id", "site", "device_id", "var_abbr")) |> 
  mutate(
    qc_code = case_when(
      !is.na(qc_value) ~ "QC 300",
      is.na(raw_value) ~ "QC 100",
      is.na(qc_value) ~ "QC 200"
    )
  )

```

```{r}
#| label: shiny-update-qc-code-do-conc-d2000
#| include: false
#| echo: false
#| eval: false

qc_update_df <- viz_data(data = do_conc3_20m, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "qc_update_df.csv")


```

```{r}
do_conc3_20m <- do_conc3_20m |> 
  update_qc_code_vectorized(qc_update_df = qc_update_df)


do <- bind_rows(do_conc3_1m, do_conc3_20m, do_1m, do_20m) 
# qc_update_df <- viz_data(data = do, qc_update_df = qc_update_df, 
#                           site_events = site_events, variable = "var_ref_id",
#                           value = "qc_value")
```



## Water temperature

```{r}
wtemp <- raw_long_device_filt |> 
  filter(var_abbr %in% c("t_wtr")) |>
  update_qc_code_vectorized(qc_update_df = qc_update_df)
```

```{r}
plot_raw_qc(data = wtemp, variable_ref = variable_ref, ylim = c(7, 30))
```



```{r}
#| label: shiny-update-qc-code-twtr-0p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "qc_update_df.csv")
```

```{r}
#| label: fig-twtr-0p5m-qc
#| fig.cap: Temperature sensor data at 1m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df)


wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d50"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature high in the bottom waters

```{r}

high_temp <- wtemp |> 
  filter(var_ref_id %in% c("t_wtr_d2050"), raw_value >= 22,raw_value <= 35) |> 
  mutate(over_22 = raw_value > 22,
         tdiff = datetime - lag(datetime, default = first(datetime)),
         group = data.table::rleid(tdiff)
  ) |> 
  group_by(var_ref_id, group) |>
  mutate(n = n(), tstep = 1:n() * 15, date = datetime[1]) |> 
  filter(n > 1, max(tstep) >= 60) |> 
  ungroup() |> 
  filter(group %in% sample(unique(group), size = 20))
high_temp

nxt_temp <- wtemp |> 
  filter(var_ref_id %in% c("t_wtr_d2000"), datetime %in% high_temp$datetime) |> 
  left_join(high_temp |> 
              select(datetime, group, date), by = c("datetime")) 

ggplot() +
  geom_point(data = high_temp, aes(datetime, raw_value, colour = var_ref_id), size = 0.2) +
  geom_line(data = high_temp, aes(datetime, raw_value, colour = var_ref_id, group = var_ref_id)) +
  geom_line(data = nxt_temp, aes(datetime, raw_value, colour = var_ref_id), size = 0.2) +
  facet_wrap(~date, scales = "free") +
  # coord_cartesian(xlim = c(0, 60 * 24), ylim = c(22, 30)) +
  # labs(x = "Minutes") +
  theme_bw()


```


### Water temperature at 1m

```{r}
#| label: shiny-update-qc-code-twtr-1m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-1m-qc
#| fig.cap: Temperature sensor data at 1m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d100")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d100"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 2.5m

```{r}
#| label: shiny-update-qc-code-twtr-2p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-2p5m-qc
#| fig.cap: Temperature sensor data at 2.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d250")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d250"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 4.5m

```{r}
#| label: shiny-update-qc-code-twtr-4p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-4p5m-qc
#| fig.cap: Temperature sensor data at 4.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d450")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d450"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 6.5m

```{r}
#| label: shiny-update-qc-code-twtr-6p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-6p5m-qc
#| fig.cap: Temperature sensor data at 6.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d650")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d650"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 8.5m

```{r}
#| label: shiny-update-qc-code-twtr-8p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-8p5m-qc
#| fig.cap: Temperature sensor data at 8.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d850")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d850"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 10.5m

```{r}
#| label: shiny-update-qc-code-twtr-10p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-10p5m-qc
#| fig.cap: Temperature sensor data at 10.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d1050")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d1050"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```
### Water temperature at 12.5m

```{r}
#| label: shiny-update-qc-code-twtr-12p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-12p5m-qc
#| fig.cap: Temperature sensor data at 12.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d1250")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d1250"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 14.5m

```{r}
#| label: shiny-update-qc-code-twtr-14p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-14p5m-qc
#| fig.cap: Temperature sensor data at 14.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d1450")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d1450"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE,
              colour = "qc_code")

```

### Water temperature at 16.5m

```{r}
#| label: shiny-update-qc-code-twtr-16p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-16p5m-qc
#| fig.cap: Temperature sensor data at 16.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d1650")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d1650"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 18.5m

```{r}
#| label: shiny-update-qc-code-twtr-18p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-18p5m-qc
#| fig.cap: Temperature sensor data at 18.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d1850")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d1850"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 20.0m

```{r}
#| label: shiny-update-qc-code-twtr-20m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-20m-qc
#| fig.cap: Temperature sensor data at 20.0m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d2000")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d2000"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

### Water temperature at 20.5m

```{r}
#| label: shiny-update-qc-code-twtr-20p5m
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = wtemp, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-twtr-20p5m-qc
#| fig.cap: Temperature sensor data at 20.5m quality control.

# wtemp <- wtemp |>
#   update_qc_code_vectorized(qc_update_df = qc_update_df, 
#                             var_ref_id = "t_wtr_d2050")

wtemp |> 
  plot_sensor(var_ref_id = c("t_wtr_d2050"), variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```

## Check for offsets between temperature nodes

Generally the temperature data falls within the expected range, but there are some offsets between the sensors. The following plot shows the estimated temperatures for 10 and 25 degrees C, 
using calculated offsets based on when the temperature difference between the 
sensors are in 5% of the distribution.

The temperature from the DO sensors (1m and 10m) have a lower accuracy (0.5 C).

```{r}
#| label: check-offsets

temp_strings <- wtemp |>
  # Filter out oxygen depths
  filter(!var_ref_id %in% c("t_wtr_d50", "t_wtr_d100", "t_wtr_d2000")) |> 
  pull(device_id) |> 
  unique()


temp_devices <- site_devices |> 
  filter(device_id %in% temp_strings)

```

```{r}
#| label: fig-check-offsets-1
#| echo: false
#| fig-cap: "Check for offsets between temperature nodes"
#| fig-width: 6
#| fig-height: 8

temp_drift <- wtemp |>
  # Filter out oxygen depths
  filter(!var_ref_id %in% c("t_wtr_d50", "t_wtr_d100", "t_wtr_d2000")) |> 
  calc_temp_drift(pctile_tdiff = 0.05,
                  date_range = c(temp_devices$date_from[1], "2009-12-31"))

plot_temp_drift(temp_drift)
```

```{r}
#| label: fig-check-offsets-2
#| echo: false
#| fig-cap: "Check for offsets between temperature nodes"
#| fig-width: 6
#| fig-height: 8

temp_drift <- wtemp |>
  # Filter out oxygen depths
  filter(!var_ref_id %in% c("t_wtr_d50", "t_wtr_d100", "t_wtr_d2000")) |> 
  calc_temp_drift(pctile_tdiff = 0.05,
                  date_range = c(temp_devices$date_from[2], "2021-12-31"))

plot_temp_drift(temp_drift)
```




# Assign QC codes for met variables

```{r}
#| label: met-assign-qc-codes

met <- raw_long_device_filt |> 
  filter(var_abbr %in% c("pp_rain", "pr_baro", "t_air", "h_rh", 
                         "w_dir", "w_spd"))

```

```{r}
#| label: shiny-update-qc-code-met
#| include: false
#| echo: false
#| eval: false
qc_update_df <- viz_data(data = met, qc_update_df = qc_update_df, 
                         site_events = site_events, variable = "var_ref_id",
                         value = "qc_value")

# write_csv(qc_update_df, "data-raw/qc_update_df.csv", append = TRUE)
```

```{r}
#| label: fig-met-qc
#| fig.cap: Temperature sensor data at 20.5m quality control.
#| fig.width: 8
#| fig.height: 8

met <- met |>
  update_qc_code_vectorized(qc_update_df = qc_update_df, 
                            var_ref_id = c("pp_rain_h150", "pr_baro_h150", 
                                           "t_air_h150", "h_rh_h150", 
                                           "w_dir_h150", "w_spd_h150"))

met |> 
  plot_sensor(var_ref_id = c("pp_rain_h150", "pr_baro_h150", "t_air_h150",
                             "h_rh_h150", "w_dir_h150", "w_spd_h150"), 
              variable_ref = variable_ref,
              sensor_calibrations = sensor_calibrations, 
              sensor_reference = sensor_reference,
              sensor_scaling = sensor_scaling, clip_ylim = FALSE, colour = "qc_code")

```


```{r}
plot_raw_qc(data = met, variable_ref = variable_ref)
```


```{r}
#| label: review-data
#| include: false
#| echo: false

data <- bind_rows(wtemp, do, met, ph_dc, chla_corr, phyc_corr) |>
  mutate(
    qc_code = case_when(
      is.na(raw_value) ~ "QC 100",
      is.na(qc_value) ~ "QC 200",
      .default = qc_code
    )
  )

data_qc_wide <- data |> 
  select(-raw_value, -device_id, -var_abbr) |> 
  pivot_wider(
    names_from = var_ref_id,
    values_from = c(qc_value, qc_code, qc_flag),
    names_sep = "_"
  ) 

dir.create("rotorua_data", showWarnings = FALSE)
write_csv(data, "rotorua_data/rotorua_qc.csv")

```


# Visual summaries

```{r}
#| label: load-data-restart
#| echo: false
#| include: false
#| eval: false

# Load the data
data_wide <- read_csv("rotorua_data/rotorua_qc.csv", col_types = cols())


data <- data_wide |> 
  pivot_longer(
    cols = matches("^(qc_value|qc_code|qc_flag)_"),
    names_to = c(".value", "var_ref_id"),
    names_pattern = "^(qc_value|qc_code|qc_flag)_(.+)$"
  ) |> 
  # Map site devices to data
  map_data_to_devices(site_devices = site_devices,
                      device_var = device_var,
                      device_position = device_position,
                      variables = variable_ref
  ) 


```

```{r}
# heck for duplicate values
# dups1 <- data |> 
#   group_by(datetime, var_ref_id) |> 
#   summarise(n = n()) |> 
#   filter(n > 1)
# dups1

```



Plot each variable

## Temperature

```{r}
#| label: fig-temp-qc
#| fig.cap: "Temperature data at various depths quality control."
#| warning: false
#| message: false
#| eval: true
#| fig.height: 10

plot_var_ts_qc(data = data, var_ref_id = c("t_wtr_d50", "t_wtr_d100",
                                           "t_wtr_d250", "t_wtr_d450",
                                           "t_wtr_d650", "t_wtr_d850",
                                           "t_wtr_d1050", "t_wtr_d1250",
                                           "t_wtr_d1450", "t_wtr_d1650", 
                                           "t_wtr_d1850", "t_wtr_d2000",
                                           "t_wtr_d2050"))

```

## Oxygen

```{r}
#| label: fig-oxygen-sat-doy-qc
#| fig.cap: "Oxygen saturation data at 1 and 10m depths quality control."

plot_var_ts_qc(data = data, var_ref_id = c("c_do_sat_d100", "c_do_sat_d2000"))

```


```{r}
#| label: fig-oxygen-doy-qc
#| fig.cap: "Oxygen data at 1 and 10m depths quality control."

plot_var_ts_qc(data = data, var_ref_id = c("c_do_d100", "c_do_d2000"))

```

## Chlorophyll

```{r}
#| label: fig-chla1-doy-qc
#| fig.cap: "Chlorophyll data at 1.0m quality control."

plot_var_ts_qc(data = data, var_ref_id = c("f_chl_d100"))

```


## Phycocyanin

```{r}
#| label: fig-phyc-doy-qc
#| fig.cap: "Phycocyanin data at 1.0m quality control."

plot_var_ts_qc(data = data, var_ref_id = c("f_phyc_d100"))

```

## pH

```{r}
#| label: fig-ph-doy-qc
#| fig.cap: "pH data at 1.0m quality control."

plot_var_ts_qc(data = data, var_ref_id = c("c_ph_d100"))

```

## Meteorological variables

::: {.panel-tabset}

```{r}
#| label: met-qc-plots
#| results: asis
#| fig-width: 14
#| fig-height: 6
#| warning: false


sel_vars <- c("h_rh_h150", "pp_rain_h150", "pr_baro_h150",
              "t_air_h150", "w_dir_h150", "w_spd_h150")

for (v in sel_vars) {
  
  var_name <- decode_var_ref(var_ref = v, variable_ref = variable_ref)
  
  cat("## ", paste(var_name$var_abbr, var_name$value_m, "m"), "\n\n")
  
  p <- plot_var_ts_qc(data = data, var_ref_id = v)
  
  print(p)
  
  cat("\n\n")
}

```

:::

```{r}
#| label: write-update-qc-df
#| echo: false
#| include: false
#| eval: false 

# write_csv(qc_update_df, "qc_update_table.csv")

```



# Download data

Download the data as a zip folder. The data is in wide format an comes with
metadata files. The metadata files contain the information needed to reconstruct
the quality control.

```{r}
#| label: write-data-to-zip-folder
#| echo: false
#| include: false
#| eval: false

# Create directory for rotorua data
path <- "rotorua_data_qc"
unlink(path, recursive = TRUE)
unlink(paste0(path, ".zip"))


# Write data and metadata to this directory
dir.create(path, showWarnings = FALSE)

data_qc_wide <- data |> 
  select(-raw_value, -device_id, -var_abbr) |> 
  pivot_wider(
    names_from = var_ref_id,
    values_from = c(qc_value, qc_code, qc_flag),
    names_sep = "_"
  ) 


# Reconvert back to long
data_qc_long <- data_qc_wide |> 
  pivot_longer(
    cols = matches("^(qc_value|qc_code|qc_flag)_"),
    names_to = c(".value", "var_ref_id"),
    names_pattern = "^(qc_value|qc_code|qc_flag)_(.+)$"
  )



# col_names <- names(data_qc_wide)
# 
# names(data_qc_wide) <- gsub("qc_value_", "", names(data_qc_wide))
# 
# 
# # Function to extract numeric depth
# extract_depth <- function(x) {
#   as.numeric(sub(".*_d([0-9]+)$", "\\1", x))
# }
# 
# # Helper to sort t_wtr columns within a prefix group
# sort_within_group <- function(vec, prefix) {
#   group_idxs <- grep(paste0("^", prefix, "t_wtr_d"), vec)
#   group_vals <- vec[group_idxs]
#   sorted_vals <- group_vals[order(extract_depth(group_vals))]
#   vec[group_idxs] <- sorted_vals
#   vec
# }
# 
# # Apply sorting for each group
# new_ord <- col_names
# new_ord <- sort_within_group(new_ord, "qc_value_")
# new_ord <- sort_within_group(new_ord, "qc_code_")
# new_ord <- sort_within_group(new_ord, "flag_")
# new_ord <- gsub("qc_value_", "", new_ord)
# 
# # Done!
# new_ord
# data_qc_wide <- data_qc_wide[, new_ord]

write_csv(site, file = file.path(path, "sites.csv"), na = "")
write_csv(data_qc_wide, file = file.path(path, "rotorua_qc.csv"), na = "")
write_csv(site_events, file = file.path(path, "site_events.csv"), na = "")
write_csv(site_devices, file = file.path(path, "site_devices.csv"), na = "")
write_csv(device_var, file = file.path(path, "device_variable.csv"), na = "")
write_csv(device_position, file = file.path(path, "device_position.csv"),
          na = "")
write_csv(sensor_reference, file = file.path(path, "sensor_reference.csv"), 
          na = "")
write_csv(sensor_calibrations, file = file.path(path, 
                                                "sensor_calibrations.csv"), 
          na = "")
write_csv(sensor_scaling, file = file.path(path, "sensor_scaling.csv"), na = "")
write_csv(variable_ref, file = file.path(path, "variables.csv"), na = "")
write_csv(qc_filters, file = file.path(path, "qc_filters.csv"), na = "")

dataspice::write_spice()

generate_readme(files_path = path, output_path = path)


# zip the folder into a zip folder
zip(zipfile = "rotorua_data_qc.zip", files = path)

```

```{r}
#| label: upload-data-github
#| include: false
#| echo: false
#| eval: false

piggyback::pb_upload(
  "rotorua_data_qc.zip",
  repo = "limnotrack/f_rotorua",
  tag = "v0.0.1", 
  overwrite = TRUE, 
  .token = Sys.getenv("GH_PAT")
)
```


<a href="https://github.com/limnotrack/f_rotorua/releases/download/v0.0.1/rotorua_data.zip" download class="btn btn-primary">Download Data</a>

